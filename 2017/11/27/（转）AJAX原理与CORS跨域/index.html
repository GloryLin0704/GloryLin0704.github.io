<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Ajax," />








  <link rel="shortcut icon" type="image/x-icon" href="/./box.ico?v=5.1.0" />






<meta name="description" content="来源：segmentfault.com ajax作为前端开发必需的基础能力之一，你可能会使用它，但并不一定懂得其原理，以及更深入的服务器通信相关的知识。在最近两天的整理过程中，看了大量的文章，发现自己的后端能力已经限制自己在网络通信相关的知识领域的探索，还是应该尽快补齐短板。 下面我们来聊一聊ajax相关的东西，包括xhr/xdr/ajax/cors/http的一部分内容，其中会抛弃一些被弃用的历">
<meta name="keywords" content="Ajax">
<meta property="og:type" content="article">
<meta property="og:title" content="（转）AJAX原理与CORS跨域">
<meta property="og:url" content="https://GloryLin0704.github.io/2017/11/27/（转）AJAX原理与CORS跨域/index.html">
<meta property="og:site_name" content="GloryLin">
<meta property="og:description" content="来源：segmentfault.com ajax作为前端开发必需的基础能力之一，你可能会使用它，但并不一定懂得其原理，以及更深入的服务器通信相关的知识。在最近两天的整理过程中，看了大量的文章，发现自己的后端能力已经限制自己在网络通信相关的知识领域的探索，还是应该尽快补齐短板。 下面我们来聊一聊ajax相关的东西，包括xhr/xdr/ajax/cors/http的一部分内容，其中会抛弃一些被弃用的历">
<meta property="og:image" content="https://glorylin0704.github.io/2017/11/27/（转）AJAX原理与CORS跨域/1.png">
<meta property="og:updated_time" content="2017-11-26T16:24:47.754Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="（转）AJAX原理与CORS跨域">
<meta name="twitter:description" content="来源：segmentfault.com ajax作为前端开发必需的基础能力之一，你可能会使用它，但并不一定懂得其原理，以及更深入的服务器通信相关的知识。在最近两天的整理过程中，看了大量的文章，发现自己的后端能力已经限制自己在网络通信相关的知识领域的探索，还是应该尽快补齐短板。 下面我们来聊一聊ajax相关的东西，包括xhr/xdr/ajax/cors/http的一部分内容，其中会抛弃一些被弃用的历">
<meta name="twitter:image" content="https://glorylin0704.github.io/2017/11/27/（转）AJAX原理与CORS跨域/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://GloryLin0704.github.io/2017/11/27/（转）AJAX原理与CORS跨域/"/>





  <title> （转）AJAX原理与CORS跨域 | GloryLin </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">GloryLin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/标签" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://GloryLin0704.github.io/2017/11/27/（转）AJAX原理与CORS跨域/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RY Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ots4cfy06.bkt.clouddn.com/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GloryLin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                （转）AJAX原理与CORS跨域
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-27T00:02:02+08:00">
                2017-11-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/11/27/（转）AJAX原理与CORS跨域/" class="leancloud_visitors" data-flag-title="（转）AJAX原理与CORS跨域">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>来源：segmentfault.com</p>
<p>ajax作为前端开发必需的基础能力之一，你可能会使用它，但并不一定懂得其原理，以及更深入的服务器通信相关的知识。在最近两天的整理过程中，看了大量的文章，发现自己的后端能力已经限制自己在网络通信相关的知识领域的探索，还是应该尽快补齐短板。</p>
<p>下面我们来聊一聊ajax相关的东西，包括<code>xhr/xdr/ajax/cors/http</code>的一部分内容，其中会抛弃一些被弃用的历史包袱，如IE6/7等。</p>
<h3 id="Ajax的出现"><a href="#Ajax的出现" class="headerlink" title="Ajax的出现"></a>Ajax的出现</h3><p>2005年，Jesse James Garrett提出了Ajax的技术，其全称为<code>Asynchronous Javascript and XML</code>，<code>Ajax</code>的核心是<code>XMLHttpRequest</code>对象，简称XHR，它用于使浏览器向服务器请求额外的数据而不卸载页面，极大的提高了用户体验。在此之前，其实这种技术已经存在并被一些人实现，但并没有流行也没有被浏览器支持。不过在此之后，IE5第一次引入XHR对象，并支持ajax技术，后续被所有浏览器支持。</p>
<h3 id="XMLHttpRequest对象和请求"><a href="#XMLHttpRequest对象和请求" class="headerlink" title="XMLHttpRequest对象和请求"></a>XMLHttpRequest对象和请求</h3><p>XHR是一个API，为客户端提供服务端和客户端之间通信的功能，并且不会刷新页面。它并不仅仅能取回XML类型的数据，而能取回所有类型的数据，除了http协议，还支持file和ftp协议。我们可以通过其构造函数来创建一个新的XHR对象，这个操作需要在其它所有操作之前完成:</p>
<p><code>var xhr = new XMLHttpRequest();</code></p>
<p>通过控制台我们可以很方便看到XHR的原型链：<code>Object -&gt; EventTarget -&gt; XMLHttpRequestEventTarget -&gt; XMLHttpRequest</code>。它拥有原型链上和本身的方法和属性，现在看下我们常用的方法：<br><img src="/2017/11/27/（转）AJAX原理与CORS跨域/1.png" alt="（转）AJAX原理与CORS跨域"><br><a id="more"></a></p>
<p>我们解释下它的几个主要方法，我们在创建了新的xhr对象之后，首先要调用它的<code>open()</code>方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一个参数可以为get/post等，表示该请求的类型</span></div><div class="line"></div><div class="line"><span class="comment">// 第二个参数是请求的url，可以为相对路径或绝对路径</span></div><div class="line"></div><div class="line"><span class="comment">// 第三个参数代表是否异步，为true时异步，为false时同步</span></div><div class="line"></div><div class="line"><span class="comment">// 第四五个参数为可选的授权使用的参数，因为安全性不推荐明文使用</span></div><div class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'example.php'</span>, <span class="literal">true</span>, username, password);</div></pre></td></tr></table></figure>
<p>在这里受同源策略的影响，当第二个参数url跨域的时候会被浏览器报安全错误。同源策略指的是当前页面和目标url协议、域名和端口均相同。后面也会讲到，除IE之外的浏览器通过XHR对象实现跨域请求，只需将url设置为绝对url即可。</p>
<p>当初始化请求完成后，我们调用<code>send()</code>方法发送请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</div><div class="line"></div><div class="line">data.append(<span class="string">'name'</span>, <span class="string">'Nicholas'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 接受一个请求主体发送的数据，如果不需要，传入null</span></div><div class="line"></div><div class="line">xhr.send(data);</div></pre></td></tr></table></figure>
<p>当请求的类型为<code>get/head</code>时，<code>send()</code>的参数会被忽略并置为<code>null</code>，<code>send()</code>传递的参数会影响到我们请求的头部<code>content-type</code>的默认值，该字段代表返回的资源内容的类型，用于浏览器处理，如果没有设置或在一些场景下，浏览器会进行MIME嗅探来确定怎么处理返回的资源。</p>
<p>在XHR2级中定义了FormData数据，用于常见的类表单数据序列化：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 直接传入表单id</span></div><div class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.getElementById(<span class="string">'user-form'</span>));</div><div class="line"></div><div class="line"><span class="comment">// 创建类表单数据</span></div><div class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</div><div class="line">data.append(<span class="string">'name'</span>, <span class="string">'Nicholas'</span>);</div><div class="line"></div><div class="line"><span class="comment">// `FormData`可以直接被send()调用，会自动修改xhr的content-type头部</span></div><div class="line">xhr.send(data);</div><div class="line"></div><div class="line"><span class="comment">// 请求头部的content-type: multipart/form-data; boundary=----WebKitFormBoundaryjn3q2KKRYrEH55Vz</span></div><div class="line"></div><div class="line"><span class="comment">// 请求的上传数据 Request Payload:</span></div><div class="line">------WebKitFormBoundaryjn3q2KKRYrEH55Vz</div><div class="line">Content-Disposition: form-data; name=<span class="string">"name"</span></div><div class="line"></div><div class="line">Nicholas</div><div class="line">------WebKitFormBoundaryjn3q2KKRYrEH55Vz--</div></pre></td></tr></table></figure></p>
<p>FormData常用的方法有<code>append/delete/entries/forEach/get/getAll/has/keys/set/values</code>，都是常用的跟数组类似的方法，不再解释。</p>
<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>GET是最常见的请求类型，可以将查询字符串参数添加到URL尾部，对XHR而言，该查询字符串必须经过正确编码，每个键值对必须使用<code>encodeURIComponent()</code>进行编码，键值对之间由&amp;分割：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 封装序列化键值对</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addURLParam</span>(<span class="params">url, name, value</span>) </span>&#123;</div><div class="line">    url += (url.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span> ? <span class="string">'?'</span> : <span class="string">'&amp;'</span>;</div><div class="line">    url += <span class="built_in">encodeURIComponent</span>(name) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(value);</div><div class="line">    <span class="keyword">return</span> url;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>POST请求使用频率仅次于GET请求，通常发送较多数据，且格式不限，数据传递给<code>send()</code>作为参数。</p>
<p>HTTP一共规定了九种请求方法，每一个动词代表不同的语义，但是常用的只有上面两种：</p>
<ul>
<li>OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。 </li>
<li>HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 </li>
<li>GET：向特定的资源发出请求。 </li>
<li>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 </li>
<li>PUT：向指定资源位置上传其最新内容。 </li>
<li>DELETE：请求服务器删除Request-URI所标识的资源。 </li>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。 </li>
<li>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li>
<li>PATCH: 用于对资源进行部分修改</li>
</ul>
<h3 id="HTTP头部信息"><a href="#HTTP头部信息" class="headerlink" title="HTTP头部信息"></a>HTTP头部信息</h3><p>每个HTTP请求和响应都带有头部信息，xhr对象允许我们操作部分头部信息。我们可以通过<code>xhr.setRequestHeader()</code>方法来设置自定义的头部信息或者修改浏览器默认的正常头部信息。常用的请求头部：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下面的实例是从我本地的一次请求取出的</span></div><div class="line"></div><div class="line">Accept: 浏览器能够处理的内容类型。<span class="comment">// */*</span></div><div class="line">Accept-Charset: 浏览器能够显示的字符集。<span class="comment">// 未取到</span></div><div class="line">Accept-Encoding: 浏览器能够处理的压缩编码。<span class="comment">// gzip,deflate</span></div><div class="line">Accept-Language: 浏览器当前设置的语言。<span class="comment">// zh-CN,zh;q=0.8,en;q=0.6</span></div><div class="line">Connection: 浏览器与服务器之间连接的类型。<span class="comment">// keep-alive</span></div><div class="line">Cookie: 当前页面设置的任意Cookie。<span class="comment">// JlogDataSource=jomodb</span></div><div class="line">Host: 发出请求的页面所在域。<span class="comment">// gzhxy-cdn-oss-06.gzhxy.baidu.com:8090</span></div><div class="line">Referer: 发出请求的页面URI。<span class="comment">// http://gzhxy-cdn-oss-06.gzhxy.baidu.com:8090/jomocha/index.php?r=tools/offline/index</span></div><div class="line">User-Agent: 浏览器的用户代理字符串。<span class="comment">// Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36</span></div></pre></td></tr></table></figure></p>
<p>我们一般不修改浏览器正常的头部信息，可能会影响到服务器响应。如果需要可以通过<code>xhr.setRequestHeader()</code>进行修改：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 传入头部键值对，键值不区分大小写，如果多次设置，则追加</span></div><div class="line"><span class="comment">// 此时请求头部的content-type: application/json, text/html</span></div><div class="line">xhr.setRequestHeader(<span class="string">'content-type'</span>, <span class="string">'application/json'</span>);</div><div class="line">xhr.setRequestHeader(<span class="string">'content-type'</span>, <span class="string">'application/json'</span>);</div></pre></td></tr></table></figure></p>
<p>设置头部信息需要在<code>open()</code>之后，<code>send()</code>之前进行调用。响应的头部信息在后端处理，不在此处讲解。有一部分请求头部信息不允许设置，如<code>Accept-Encoding, Cookie</code>等。</p>
<p>在请求返回后，我们可以获取到响应头部：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取指定项的响应头</span></div><div class="line">xhr.getResponseHeader(<span class="string">'content-type'</span>); <span class="comment">// application/json;charset=utf-8</span></div><div class="line"><span class="comment">// 获取所有的响应头部信息</span></div><div class="line">xhr.getAllResponseHeaders();</div></pre></td></tr></table></figure></p>
<p>这里简单说下<code>content-type</code>值，指的是请求和响应的HTTP内容类型，影响到服务器和浏览器对数据的处理方式，默认为<code>text/html</code>，常用的如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 包含资源类型，字符编码， 边界字符串三个参数，可选填</span></div><div class="line"></div><div class="line">text/html;charset=utf<span class="number">-8</span>    <span class="comment">// html标签文本</span></div><div class="line">text/plain    <span class="comment">// 纯文本</span></div><div class="line">text/css    <span class="comment">// css文件</span></div><div class="line">text/javascript    <span class="comment">// js文件</span></div><div class="line"><span class="comment">// 普通的表单数据，可以通过表单标签的enctype属性指定</span></div><div class="line">application/x-www-form-urlencode</div><div class="line"><span class="comment">// 发送文件的POST包，包过大需要分片时使用`boundary`属性分割数据作边界</span></div><div class="line">multipart/form-data; boundary=something</div><div class="line"><span class="comment">// json数据格式</span></div><div class="line">application/json</div><div class="line"><span class="comment">// xml类型的标记语言</span></div><div class="line">application/xml</div></pre></td></tr></table></figure></p>
<h3 id="XHR对象的响应"><a href="#XHR对象的响应" class="headerlink" title="XHR对象的响应"></a>XHR对象的响应</h3><p>我们现在对请求的发起很了解了，接着看下如何拿到响应数据。如果我们给<code>open()</code>传递的第三个参数是true，则代表为同步请求，那么js会被阻塞直到拿到响应，而如果为false则是异步请求，我们只需要绑定<code>xhr.onreadystatechange()</code>事件监听响应即可。最上面的图已经说明了<code>readystate</code>的值含义，所以我们可以：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// xhr v1 的写法，检测readystate的值，为4则说明数据准备完毕，需要在open()前定义</span></div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>） &#123;</div><div class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span> || xhr.status === <span class="number">304</span>) &#123;</div><div class="line">            <span class="built_in">console</span>.log(xhr.responseText);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">console</span>.log(xhr.statusText);</div><div class="line">        &#125;</div><div class="line">    &#125;   </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// xhr v2 的写法，onload()事件说明数据准备完毕</span></div><div class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (xhr.status === <span class="number">200</span> || xhr.status === <span class="number">304</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(xhr.responseText);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(xhr.statusText);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>xhr对象的响应数据中包含几个属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">response    <span class="comment">// 响应的数据</span></div><div class="line">responseURL    <span class="comment">// 发起响应的URL</span></div><div class="line">responseType    <span class="comment">// 响应的类型，用于浏览器强行重置响应数据的类型</span></div><div class="line">responseText    <span class="comment">// 如果为普通文本，则在这显示</span></div><div class="line">responseXML    <span class="comment">// 如果为xml类型文本，在这里显示</span></div></pre></td></tr></table></figure></p>
<p>数据会出现在<code>responseText/responseXML</code>中的哪一个，取决于服务器返回的MIME类型，当然我们也有一些方式在浏览器端设置如何处理这些数据：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// xhr v1 的写法，设置响应资源的处理类型</span></div><div class="line">xhr.overrideMimeType(<span class="string">'text/xml'</span>);</div><div class="line"></div><div class="line"><span class="comment">// xhr v2 的写法， 可用值为 arraybuffer/blob/document/json/text</span></div><div class="line">xhr.responseType = <span class="string">'document'</span>;</div></pre></td></tr></table></figure></p>
<p>响应数据相关的属性默认为<code>null / &#39;&#39;</code>，只有当请求完成并被正确解析的时候才会有值，取决于<code>responseType</code>的值，来确定<code>response/responseText/responseXML</code>谁最终具有值。</p>
<h3 id="XHR的高级功能"><a href="#XHR的高级功能" class="headerlink" title="XHR的高级功能"></a>XHR的高级功能</h3><p>在xhr v2里提供了超时和进度事件。</p>
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xhr.timeout = <span class="number">1000</span>;    <span class="comment">// 1分钟，单位为ms</span></div><div class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div></pre></td></tr></table></figure>
<p>在请求<code>send(</code>)之后开始计时，等待<code>timeout</code>时长后，如果没有收到响应，则触发<code>ontimeout()</code>事件，超时会将<code>readystate=4</code>，直接触发<code>onreadystatechange()</code>事件。</p>
<h3 id="请求进度"><a href="#请求进度" class="headerlink" title="请求进度"></a>请求进度</h3><p>像上图所示，xhr v2定义了不同的进度事件：<code>loadstart/progress/error/abort/load/loadend</code>，这其中我们已经说过了<code>onload()</code>事件为内容加载完成可用。现在说一下`onprogress()``进度事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (event.lengthComputable) &#123;</div><div class="line">        <span class="built_in">console</span>.log(event.loaded / event.total);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该事件会接收一个<code>event</code>对象，其<code>target</code>属性为该xhr对象，<code>lengthComputable</code>属性为<code>total size</code>是否已知，即是否可用进度信息，<code>loaded</code>属性为已经接收的字节数，<code>total</code>为总字节数。该事件会在数据接收期间不断触发，但间隔不确定。</p>
<h3 id="跨域CORS"><a href="#跨域CORS" class="headerlink" title="跨域CORS"></a>跨域CORS</h3><p>提到XHR对象，我们就会讲到跨域问题，它是为了预防某些恶意行为的安全策略，但有时候我们需要跨域来实现某些功能。需要注意的是跨域并不仅仅是前端单方面的事情，它需要后端代码进行配合，我们只是通过一些方式跳过了浏览器的阻拦。</p>
<p>对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。</p>
<p><code>CORS(Cross-Origin Resource Sharing</code>, 跨域资源共享)的思想是浏览器和服务端通过头部信息来进行沟通确认是否给予响应。如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Origin: http:<span class="comment">//www.baidu.com    // 浏览器的头部信息</span></div><div class="line"></div><div class="line"><span class="comment">// 如果服务端认可这个域名的跨域请求，如下设置就可跨域访问资源</span></div><div class="line">Access-Control-Allow-Origin: http:<span class="comment">//www.baidu.com</span></div></pre></td></tr></table></figure></p>
<p>如上就可以实现最简单的跨域访问，但是此时不能携带任何的cookie，如果我们需要传递cookie进行身份认证，需要设置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xhr.withCredentials = <span class="literal">true</span>;    <span class="comment">// 浏览器端</span></div><div class="line">Access-Control-Allow-Credentials: <span class="literal">true</span>;    <span class="comment">// 服务端</span></div></pre></td></tr></table></figure></p>
<p>这样我们就可以传递认证信息了，但如果允许认证，Access-Control-Allow-Origin不能设置为*，而一定是具体的域名信息。</p>
<p>现在的浏览器都对CORS有了实现，如IE使用XDomainRequest对象，其它浏览器使用<code>XMLHttpRequest</code>对象。所以在此之前有很多奇技淫巧，如通过<code>jsonp</code>/图像 Ping方法都不再详述，而且其都需要服务端配合并且有很多局限性。</p>
<h3 id="IE实现：-XDomainRequest"><a href="#IE实现：-XDomainRequest" class="headerlink" title="IE实现： XDomainRequest"></a>IE实现： XDomainRequest</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xdr = <span class="keyword">new</span> XDomainRequest();</div><div class="line">xdr.open(<span class="string">'get'</span>, <span class="string">'http://www.site.com/page'</span>);</div><div class="line">xdr.send(<span class="literal">null</span>);</div></pre></td></tr></table></figure>
<p>XDR区别于普通XHR：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">不能传输cookie</div><div class="line">只能设置请求头部的content-type</div><div class="line">不能访问响应头部信息</div><div class="line">只支持get/post方法</div></pre></td></tr></table></figure></p>
<p>通过这些区别可以阻止一部分的CSRF(Cross-Site Request Forgery，跨站点请求伪造)和XSS(Cross-Site Scripting，跨站点脚本)。</p>
<p>XDR与XHR的使用上非常相似，区别有几点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">open()方法只接受两个参数，请求类型和URL</div><div class="line">只允许异步请求</div><div class="line">响应完成触发onload()事件，但我们只能访问responseText原始文本，并且无法获取响应的status.</div><div class="line">异常事件都会触发error事件，并且无错误信息可用。</div></pre></td></tr></table></figure></p>
<h3 id="其余浏览器实现：-XMLHttpRequest"><a href="#其余浏览器实现：-XMLHttpRequest" class="headerlink" title="其余浏览器实现： XMLHttpRequest"></a>其余浏览器实现： XMLHttpRequest</h3><p>其余浏览器通过XHR对象直接实现了CORS，你只需要做的就是open()方法中传入一个绝对URL。</p>
<p><code>xhr.open(&#39;get&#39;, &#39;http://www.site.com/page&#39;, true);</code></p>
<p>相对于普通的XHR对象，CORS-XHR依然有部分限制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">不能使用setRequestHeader()定义头部</div><div class="line">不能传递cookie</div><div class="line">调用getAllResponseHeaders()，结果为空</div></pre></td></tr></table></figure></p>
<h3 id="其余跨域方法"><a href="#其余跨域方法" class="headerlink" title="其余跨域方法"></a>其余跨域方法</h3><p>上面的两种方法已经很成熟了，但是仍然有一部分方法可以跨域，比如图像Ping：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</div><div class="line">img.onload = img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>);</div><div class="line">&#125;</div><div class="line">img.src = <span class="string">'http://www.site.com/test?name=Nicholas'</span>;</div></pre></td></tr></table></figure></p>
<p>这种方式常用于服务端统计广告的点击次数，其缺陷为：</p>
<p>另外还有JSONP：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(response.ip, response.city);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">script.src = <span class="string">'http://freegeoip.net/json?callback=handleResponse'</span>;</div><div class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.firstChild);</div></pre></td></tr></table></figure></p>
<p>这种方式通过和服务器配合，跨域请求一个js文件并被服务器处理后传回：</p>
<p><code>handleResponse({&#39;name&#39;: &#39;Nicholas&#39;});</code></p>
<p>然后直接在浏览器调用了该函数，传回的数据被当做response形参进行处理。但它也有一些缺陷：</p>
<p>访问的方式是请求js，所以如果域名不安全，则很容易被恶意代码直接执行并攻击<br>无法检测是否错误，因为js不支持这样的接口事件，只能超时判断<br>上面两种方式很容易看出，我们在支持CORS之前，使用的方法只不过是采用img/css/js等不受跨域访问限制的对象，变相拿到了响应数据，但都有缺陷，所以如果没有历史包袱，建议采用XDR或XHR对象来实现跨域访问。</p>
<hr>
<blockquote>
<p>原文地址：<a href="https://segmentfault.com/a/1190000011549088?utm_source=funteas.com&amp;utm_medium=article&amp;utm_content=web" target="_blank" rel="external">https://segmentfault.com/a/1190000011549088?utm_source=funteas.com&amp;utm_medium=article&amp;utm_content=web</a></p>
</blockquote>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Ajax/" rel="tag"># Ajax</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/08/Promise/" rel="next" title="ES6-Promise">
                <i class="fa fa-chevron-left"></i> ES6-Promise
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/31/TheLast/" rel="prev" title="The Last For 2017">
                The Last For 2017 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ots4cfy06.bkt.clouddn.com/avatar.png"
               alt="RY Lin" />
          <p class="site-author-name" itemprop="name">RY Lin</p>
           
              <p class="site-description motion-element" itemprop="description">努力活成你喜欢的样子</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Ajax的出现"><span class="nav-number">1.</span> <span class="nav-text">Ajax的出现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XMLHttpRequest对象和请求"><span class="nav-number">2.</span> <span class="nav-text">XMLHttpRequest对象和请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#请求方法"><span class="nav-number">3.</span> <span class="nav-text">请求方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP头部信息"><span class="nav-number">4.</span> <span class="nav-text">HTTP头部信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XHR对象的响应"><span class="nav-number">5.</span> <span class="nav-text">XHR对象的响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XHR的高级功能"><span class="nav-number">6.</span> <span class="nav-text">XHR的高级功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#超时"><span class="nav-number">7.</span> <span class="nav-text">超时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#请求进度"><span class="nav-number">8.</span> <span class="nav-text">请求进度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跨域CORS"><span class="nav-number">9.</span> <span class="nav-text">跨域CORS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IE实现：-XDomainRequest"><span class="nav-number">10.</span> <span class="nav-text">IE实现： XDomainRequest</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其余浏览器实现：-XMLHttpRequest"><span class="nav-number">11.</span> <span class="nav-text">其余浏览器实现： XMLHttpRequest</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其余跨域方法"><span class="nav-number">12.</span> <span class="nav-text">其余跨域方法</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RY Lin</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("xFdbk7yQqTgp4x02upKx64T5-gzGzoHsz", "0K2w4z8XKlmJhIDXKiAla2ES");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

</body>
</html>
